{"version":3,"sources":["util.ts","Board.ts","boggle.ts","App.ts","index.js"],"names":["dom","React","Board","_this","this","props","boardMatrix","map","row","i","key","letter","j","style","maxWidth","maxLength","value","onChange","evt","l","target","match","setBoard","toUpperCase","Component","getRange","val","boardSize","r","getNeighborLetters","col","board","length","coords","findNeighbors","idx","word","prevCoord","usedCoords","neighbors","candidate","x","startBoard","startingCandidates","findLetterCandidates","solveBoard","flattenedBoard","allPossibleWords","w","DICTIONARY","console","log","split","App","state","boggleBoard","words","_this2","margin","alignText","display","justifyContent","marginTop","_ref","_ref2","Object","slicedToArray","setState","concat","toConsumableArray","Infinity","onClick","alert","ReactDOM","render","react_default","a","createElement","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.d4f6a06e.chunk.js","sourcesContent":["import * as React from \"react\";\n\nexport const dom = React.createElement;","import {Component} from \"react\";\nimport { dom } from \"./util\";\nimport { BoggleBoard, Coordinate } from \"./types\";\n\ntype Props = {\n    boardMatrix: BoggleBoard,\n    setBoard: (coords: Coordinate, letter: string) => void;\n}\n\nclass Board extends Component<Props, {}> {\n    render() {\n        return dom(\"table\", {}, \n            dom(\"tbody\", {},\n            this.props.boardMatrix.map((row: string[], i: number) => \n                dom(\"tr\", {key: i}, \n                    row.map((letter: string, j: number) => \n                        dom(\"td\", {key: j}, \n                            dom(\"input\", {\n                                style: {maxWidth: \"1em\"},\n                                maxLength: 1,\n                                value: letter, \n                                onChange: (evt) => {\n                                    const l = evt.target.value;\n                                    if (l.match(/([a-zA-Z]{1})/)) {\n                                        this.props.setBoard([i, j], l.toUpperCase())\n                                    }\n                                }\n                            })\n                                    \n                        )\n                    )\n                )\n            )\n        ))\n    }\n}\n\nexport default Board;","import * as r from \"ramda\";\nimport { BoggleBoard, Neighbor, Coordinate } from \"./types\";\nimport DICTIONARY from \"./word_compiler/dictionary.json\"\n\nexport const getRange = (val: number, boardSize: number): number[] =>\n  r.range(\n    val > 0 ? val - 1 : val,\n    val < boardSize - 1 ? val + 2 : val + 1\n  )\n\nexport const getNeighborLetters = r.memoizeWith(r.identity, \n  (row: number, col: number, board: BoggleBoard): Neighbor[] => \n    r.unnest(getRange(row, board.length).map(\n      (i: number) => {\n        return getRange(col, board.length).map(\n          (j: number): Neighbor => \n            ({coords: [i, j], letter: board[i][j]})\n        )\n      }\n    )\n  )\n)\n\nexport const findLetterCandidates = (letter: string, board: BoggleBoard): Coordinate[] => \n    r.unnest(r.range(0, board.length).map(\n      (i: number) => \n        r.reject(r.isNil, \n          r.range(0, board.length).map(\n            (j: number) => \n              board[i][j] === letter \n                ? [i, j] \n                : null\n          )\n        )\n    )) as Coordinate[]\n\nexport const findNeighbors = (idx: number, word: string[], prevCoord: Coordinate, usedCoords: Coordinate[], board: BoggleBoard): boolean => {\n  // Base Case; made whole word\n  if (idx === word.length) {\n    return true\n  }\n\n  // Base Case: could not find next letter\n  const neighbors = r.filter(\n    (candidate: Neighbor) => candidate.letter === word[idx] && !r.includes(candidate.coords, usedCoords),\n    getNeighborLetters(prevCoord[0], prevCoord[1], board)\n  )\n\n  if (neighbors.length === 0) {\n    return false\n  }\n\n  // Recursive case: have neighbor candidates to check\n  return r.any((x) => x, neighbors.map(\n    (candidate) => findNeighbors(\n      idx + 1, \n      word, \n      candidate.coords, \n      r.append(candidate.coords, usedCoords),\n      board\n    )\n  ))\n}\n\nexport const startBoard = (word: string[], board: BoggleBoard) => {\n  const startingCandidates = findLetterCandidates(word[0], board)\n  \n  for (let i in startingCandidates) {\n    if (findNeighbors(1, word, startingCandidates[i], [startingCandidates[i]], board)) {\n      return true\n    }\n  }\n  return false \n}\n\nconst filterDictForBoard = (flattenedBoard: string[]) => r.filter(\n  (w: string) => r.includes(w[0], flattenedBoard),\n  DICTIONARY\n)\n\nexport const solveBoard = (board: BoggleBoard): string[] => {\n  const allPossibleWords = filterDictForBoard(r.flatten<string>(board))\n  console.log(allPossibleWords)\n\n  return r.reject(r.isNil, r.uniq(r.map(\n    (word: string) => startBoard(word.split(\"\"), board) ? word : null, allPossibleWords\n    ))\n  ) as string[]\n}","import { Component } from 'react';\nimport Board from \"./Board\"\nimport { dom } from './util';\nimport { solveBoard } from './boggle';\nimport * as r from \"ramda\"\nimport { Coordinate, BoggleBoard } from './types';\n\ntype State = {\n  boggleBoard: BoggleBoard;\n  words: string[]\n}\n\nclass App extends Component<{}, State> {\n  state: State = {\n    boggleBoard: r.range(0, 4).map((i: number) =>\n      r.range(0, 4).map((j: number) => \"\")),\n    words: []\n  }\n\n  render() {\n    return dom(\n      \"div\", {style: {margin: \"5em\", alignText: \"center\"}},\n      dom('div', {style: {display: \"flex\", justifyContent: \"center\"}},\n        dom(\"h1\", {}, \"Let's Solve Boggle!\")\n      ),\n      dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n        dom(Board, {\n          boardMatrix: this.state.boggleBoard, \n          setBoard: ([i, j]: Coordinate, letter: string) => \n            this.setState({\n              boggleBoard: [\n                ...r.slice(0, i, this.state.boggleBoard),\n                r.update(j, letter, this.state.boggleBoard[i]),\n                ...r.slice(i+1, Infinity, this.state.boggleBoard)\n              ]\n            }) \n        }),\n      ),\n      dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n        dom(\"button\", {onClick: () => {\n          if (r.any((l: string) => l === \"\", r.flatten<string>(this.state.boggleBoard))) {\n              alert(\"board incomplete\")\n          }\n          else {\n              this.setState({\n                words: solveBoard(this.state.boggleBoard)\n              })\n          }\n      }}, \"Submit Board\")\n        ),\n    dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n      dom(\"ul\", {},\n        r.map((word: string) => dom(\"li\", {key: word}, word), this.state.words)\n        )\n      )\n\n    )\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\n"],"sourceRoot":""}